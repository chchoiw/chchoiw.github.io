---
title: '02331-數據結構'
date: 2021-09-28
permalink: /posts/2021/09/02331/
tags:
  - 數據結構
category:
  - Computer Science
---


- [第三章](#第三章)
  - [隊列](#隊列)
    - [數組隊列](#數組隊列)
    - [鏈隊列](#鏈隊列)
  - [中綴表達和后綴表達](#中綴表達和后綴表達)
- [第四章](#第四章)
  - [矩陣](#矩陣)
- [第五章](#第五章)
  - [二叉樹](#二叉樹)
  - [樹和森林](#樹和森林)
  - [哈夫曼樹](#哈夫曼樹)
- [第六章 圖](#第六章-圖)
  - [搜索遍歷](#搜索遍歷)
  - [最小生成樹](#最小生成樹)
    - [Prim算法](#prim算法)
    - [Kruskal算法](#kruskal算法)
  - [最短路徑](#最短路徑)
    - [Dijkstra](#dijkstra)
  - [拓扑排序](#拓扑排序)
  - [第七章 排序](#第七章-排序)
    - [插入排序](#插入排序)
  - [交換排序](#交換排序)



# 第三章

## 隊列

### 數組隊列
- 空隊列時
  - font=0, rear=0
- 非空隊列時
  - font是出隊,非空隊列font是有內容
  - rear是入隊,非空隊列rear是最後有內容的後一個位置,沒有內容
- 元素個數:
  
  $$
  n+\text{rear}-\text{font} \quad \text{(mod n)}
  $$
  
  $n$為隊列長度
### 鏈隊列

- 空隊列時
  
```
Q->font=head=Q->rear
head->next=Null
```

- 非空隊列時
  - font的指針指向head,但head沒有內容
  - rear的指針指向隊尾,p->rear->data是有內容的


## 中綴表達和后綴表達

| 中綴表達式       | 運算付棧OS      | 后綴表達式      |
|  ---  |  ---  |  ---  |
|9-(2+4*7)/5+3 #      | #      |    空   |
|  )/5+3            | #-(+*      |9347
|    /5+3   |    #-   |   9347*+    |
|    5+3   |    #-/   |   9347*+    |
|    +3   |    #-/   |   9347*+5    |
|    3   |    #+   |   9347*+5/-    |
|    空  |    #   |   9347*+5/-3+    |

- 總結兩個規則
- ()集齊了,()內的符號退棧, 進棧到后綴中
- 若下一個運算符號優先次序低於棧中, 先將運算棧中的全部運算符號退棧, 再將低優先次序的符號進棧




# 第四章

## 矩陣

$$
A_{m\times n}=
\left[
\begin{matrix}
a_{00} &\dots &a_{0,n-1} \\
\vdots &\ddots &\vdots \\
a_{m-1,0}&\dots &a_{m-1,n-1}
\end{matrix}
\right]
$$

寫成

$$
A=
[[a_{00},...,a{1,n-1}],...[a_{m-1,0},...,a_{m-1,n-1}]]
$$


- 按行(橫)存:
  
  $$
    a_{00},a_{01},\dots,a_{m-1,n-1}
  $$

- 按列(縱)存:
  
  $$
    a_{00},a_{1,0},\dots,a_{m-1,n-1}
  $$

- 對稱

$$  
\Bigg\{
\begin{array}{cccc}
\frac{i(i+1)}{2}+j \quad & i\geq j  \\
\frac{j(j+1)}{2}+i \quad & i<j
\end{array}
$$


# 第五章

## 二叉樹

- 在$i$層,最多有$2^{i-1}$個結點
- 深度為$k$的二叉樹,最多有$2^{k}-1$結點
- 終端結點$n_0$,度數為2的結點數為$n_2$,

$$
n_0=n_2+1
$$

- 完全二叉樹:深度為$k$的二叉樹, 在前$k-1$層是滿樹,第$k$層的結點都在左邊。則有$n$結點的深度$k$

$$
k=\lfloor\log n\rfloor +1  \quad \text{or} \quad k=\lceil \log (n+1) \rceil
$$ 

- 前序歷遍:根左右
- 中序歷遍:左根右
- 後序歷遍:左右根
- 已知前序中序或中序後序確定二叉樹

- 線二叉樹

  |lchild       |  ltag     |   Data    | rtag      |rchild       |

$$
\text{ltag}=
\Bigg\{
\begin{array}{cccc}
&0 \quad &\text{lchild指向左孩子}\\
&1 \quad &\text{lchild指向前趨}
\end{array}
$$

$$
\text{rtag}=
\Bigg\{
\begin{array}{cccc}
&0 \quad &\text{rchild指向右孩子}\\
&1 \quad &\text{rchild指向后繼}
\end{array}
$$

這裏前趨後繼是根據前,中和後序其中一㮔排序算法,沒有特別指出,就假設是中序。

## 樹和森林

- 樹變二叉樹:
  - 兄弟連成線, 只保留長子

- 樹前序:根,長子,長子的長子
- 樹很序:長子的盡頭(a),a的兄弟的長子的盡頭(b), 沒有兄弟就是上一個結點,
  
## 哈夫曼樹
- 最小兩個的比重做成一個, 代表原本的放入數列
- 同复上術步驟
- 比重大的一側為0,小的一則為1
- 則可由經過的路徑組成編碼
  


# 第六章 圖


- 無向圖邊數:$e\leq\frac{n(n-1)}{2}$
- 無向圖邊數:$e\leq\ n(n-1)$
- 連通圖:任意兩點都有連接
  
## 搜索遍歷
- 深度搜索遍歷(DFS):矩陣$O(n^2)$,鄰接表$O(n+e)$
- 廣度搜索遍歷(BFS):矩陣$O(n^2)$,鄰接表$O(n+e)$


## 最小生成樹
- 極小連通子圖:若在圖中去掉一邊,會變成非連通。若加一邊，則有回路

### Prim算法
- 先選一點$U=\{x\}$
- 再從已歸納的點集$U$中可伸展的邊,選出來, 並將這邊頂點歸納在$U$中，並重覆，直至$U$包括了所有的頂點
- $O(n^2)$

### Kruskal算法
- 所有頂點在原處,選最小權的邊,直至成為連通圖

## 最短路徑

### Dijkstra
- 尋找某一點$V_0$到其他點的最短路徑
- 無路徑通往的頂點設為$\infty$
- 選連通權數最少又不在集合$U$中的頂點加入$U$,更新加入$U$後的有限路徑中選取權數最少的路徑
- 重覆上述步驟, 直至$U$包括所有的頂點, 這時$V_0$到其他頂點的最短路徑產生
  

## 拓扑排序
- 入度為0的頂點, 輸出它,並刪除它與它的出線
- 重覆以上動作,就找到排序
- 排序不唯一


## 第七章 排序

相同紀錄，若排序時相對位置持保持，則稱為穩定

### 插入排序

- 直接排序
  - $A=\{a_1\}$ 為以排序的，$B=\{a_2,\dots,a_n\}$ 為未排序
  - 將$B$中與$A$最後的元素比較，比$A$小的才向前移動，直至不再比較小，將元素直接插入$A$,並向後移動比它大的，如此類推
  - 在$i$中，最多向後移動$i+1$次，最多比較$i$次
  - 最好的情況$O(n)$，最壞的情況$O(n^2)$,平均$O(n^2)$
  - 空間$O(1)$
  - 穩定的
- 希爾排序
  - $a_1$為數列第一項，不是$a_0$,z設$d_1$為間距，將數列分成
    
    $$
    \{a_1,a_1+d_1,a_1+2d_1\} \quad \{a_2,a_2+d_1,a_2+2d_1\} \quad \dots
    $$

  - 在上述集合中進行**直接排序**

  - 取$d_2<d_1$,重覆上述
    
    $$
    \{a_1,a_1+d_2,a_1+2d_2\} \quad \{a_2,a_2+d_2,a_2+2d_2\} \quad \dots
    $$

  - 最後隔距$d_l=1$
  - $n$很大時，比直接排序時間和移動少很多,
  - 移動和比較次數約為$n^{1.25}-1.6n^{1.25}$
  - 不穩定的，因為$d$會令相同數值的後面的元素向前移動
  
## 交換排序
- 冒泡排序
  - 從後到前，有後比前小的交換，第一個出來的一定是最少
  - 如此類推，直至排序完成
  - 若第一趟沒有置換，則排序完成
  - 最好的情況$O(n)$，最壞的情況$O(n^2)$,平均$O(n^2)$
  - 穩定的
- 快速排序
- $B=a_1$為基準
- $i=1,j=n$
- for some biggest j_b $a_{j_b}<B$ for some biggest $j$, 
  
  $$a_i=a_j \quad j=j_{b} \quad i=i+1$$

- for some smallest i_s $a_{i_s}>B$ for some smallest $i$, 
  
  $$a_j=a_i \quad i=i_{s} \quad j=j+1$$

- 不穩定的，因為$i,j$互換數值
- 平均時間$O(n \log_2 n)$,排序已為有序時，時間$O(n^2)$
- 空間時間$O(n \log_2 n)$，棧最大深度為$\lceil n \log_2 n \rceil+1$