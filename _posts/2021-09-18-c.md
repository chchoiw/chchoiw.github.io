---
title: '04737-C++程序設計'
date: 2021-09-28
permalink: /posts/2021/10/04737/
tags:
  - C++
category:
  - Computer Science
---


- [挺好的解釋網站](https://openhome.cc/Gossip/CppGossip/index.html)


# 第一章


## C++ 語言特點

- 可運行多種平台
- 加入了面向對象；

## 類型轉換
```
# double-> int
oneInt2=static_cast<int>(onDouble);
```

```
int a=1;
const int *p =&a;
// 去除const int *，轉變為 int *
q=const_cast<int *>p;
```


# 第四章

## 解析函數
- 沒有參數,沒有返回植
- 有且只有一個
- 不會有重載的析構函數


## 靜態變量
- static: 靜態全局變量
- 在函體中可見,程序結束時釋放占用的空間,所以若在函數內定義, 出了函數就消失
- 類的靜態成員函數沒有this指針
- 靜態成員函數井不作用某個具體對象,不會改變對象中非靜態成員變量的值
- 不能在靜態成員函數內訪問非靜態的成員
- 靜態成員都只有一份保存在公用內存中
- 必須在類體外定義靜態成員變量的初值


## 常量成員和常引用成員
- 它既可以調用常量成員函數, 也可以調用普通成員函數
- 靜態成員函數井不作用某個具體對象,不會改變對象中非靜態成員變量的值,所以常數成員函數和非常量成員函數內部都可以調用靜態成員變量的值
- const成員變量必須在構造函數的初始化列表中進行初始化


# 第四章

- ```this```是指向类或者结构体本身的指针，并且不可以改变。
- ```*this```就是指向本身的类或结构体的变量。
- ```*p=&a``` *p是指標變量,可以存地址, &a 是a 的地址
- ```p```是地址, ```*p```是該地址的值
- ```int *p=new int()```在這段程式中，new 運算子會配置 int 需要的空間，並傳回該空間的位址，可以使用指標 p 來儲存位址


# 第五章
- 基類有友元類或友元函數,派生類不會因繼承關係而也有此友元類或友元函數。
- 基類是某類的友元, 是會被繼承
- 除基類的構造函數和析構函數外,派生類可以繼承基類的全部成員變量和成員函數

# 第六章
## 多態與虛函數
- P.245
- 多態為了接口复用
- 多態前不能提前知曉指針指向，函數調用與代碼入口地址需要綁定時才能確定，為**動態綁定**
- 早綁定是靜態綁定

滿足動態綁定的2個條件
- 必須聲明虛函數
- 通過基類類型指針或引用調用虛函數

虛函數：  
- 通常虛函數不是內聯函數
- 實現多態是派生和基類的同名函數，參數列表，返回值都一樣
- 基類定義了虛，派生也是虛
- 靜態成員函數和友元函數不能為虛
- 虛函數定義在類外，只而聲明時加 virtal ,定義時不用
- 構造函數不能是虛函數,operator=最好也不要是虛函數
- 構造和析構最好不要調用虛函數

不能聲明為虛函數： 
- 全局函數不能是虛
- 構造不能是虛
- 靜態
- 內聯成員函數
- 友元

  

## 虛析構函數
- p.263
- 沒有返回值
- 沒有參數
- 對象消忘時實現多態
  
```
int main()
{
  ABase *p=new Derived();
  delete p; return 0;
}
```
- 若基類的析構函數是虛，```delete p```就是先執行Derived析構函數 , 後執行base析構函數
- 若基類的析構函數不是虛，```delete p```就是執行base析構函數

## 純虛函數
- p.266
- 不可創純虛函數的對象，但可引用或指針。

## 虛基類

- A是基
- B，C是A的派生
- D，是B和C的派生

```C
class B :virtual public A
{};
Class C : virtual public A
{};
Class D:public B,public C
{};
```


# 第七章
- P.277
- iomanip包括了格式化I/O帶參數操縱符
- cerr非緩沖輸出流
- clog緩沖輸出流

```
if (cin.eof()){}
```

##  控制I/O操縱符
- iostream
  - endl:新行符，清空流(O)
  - ends:(O)
  - flush：清空緩沖區(O)
  - dec*:10進制(I/O)
  - hex：16進制(I/O)
  - oct:8進制(I/O)
  - ws：提取空白符(O)
  
- iomainip
  - p.284
  - fixed:小數記數
  - left:向左靠
  - right*:向右靠
  - scientific：科學記數
  - setbase()：數字的基
  - setw()：輸出的寬
  - setfill():空的位置的填滿符
  - setprecision：小數或科學的小數後準確度，若不是fixed或scientific，就是從頭的數字數起，而不是小數後數起

```
double x=1.23456789
cout<<setprecision(x); // 1.2346
cout<<fixed<<setprecision(x); // 1.23457
cout<<scientific<<setprecision(x); // 1.23457e+000
```

- 標志字
  - setiosflags 是持久的，直到resetiosflag
  
```
cout<<setiosflags(ios::scienfitic|ios::showpos);
cout<<resetiosflags(ios::scienfitic)
```

## cout

- P.289
  
```
cout.fill("*");
cout.width();
cout.precision();
cout.setf(ios::scienfitic);
cout.unsetf(ios::scienfitic);
```

- 字符插入
  
```
ostream &put(char c);
ostream & write(const char *pch, int nCount); // pch 指向長度為nCount的字符
```


## cin
```
while(ch=cin.get()!=EOF)
{ }
```

```
istream & getline(char *buf ,int bufSize) // 讀bufSize-1個字符到緩沖區或讀到"\n",結尾自動加"\0"
istream & getline(char *buf, int bufSize,char delim);// 讀bufSize-1個字符到緩沖區或讀到delim,結尾自動加"\0"
istream & ignore(int n=1, int delim=EOF)// 跳過頭n個字符或delim前的字符
bool eof()
peek() //返回輸入流的當前字符，但不會從輸入流中取出，即看一眼
```

```
cin.getline();
cin.eof();
cin.ignore();
cin.peek();
```

# 第八章

p.305

```
#讀入
int main()
{
  int a,b,c;
  ifstream  inFile;
  inFile.open("data.txt" ,ios::in);
  while(inFile>>a>>b>>c)
  {

  }
  inFile.close();
  return 0;
}

```

```
寫出
#int main()
{
  int a,b,c;
  ofstream  onFile;
  onFile.open("data.txt" ,ios::out);
  onFile<<a<<b<<endl;
  onFIle.close();
  return 0;
}
```

## 二進制
```
// buffer 指向長度nCount寫入
ostream &write(char * buffer ,int nCount);
// buffer 指向長度nCount讀入
istream &read(char * buffer ,int nCount);
Cstudent stu; // a class
while (inFile.read( (char *) &stu , sizeof (stu)) )
{
` cout<<stu.id<<stu.name<<endl;
}
// read 成功讀取的字節數
int gcount;
//每次寫入一個字節
ostream & put(char ch ) ;
// 每次取一個字節
instream &get (char *pch , int nCount, char delim="lim"  );
```

## 隨機存取

```
// 將指針設置為pos， seek_dir方向移動pos個字節
istream & seekg(long pos ios::seek_dir dir);
long tellg();
ostream & seekp(long pos ios::seek_dir dir);
long tellp();
inFile.clear();
```

# 第九章

```
template <typename T>
T abs(Tx){}
template <class T1>
void Swap(T &x, T&y)
{
  T tmp=x;
  x=y;
  y=tmp;
}

int main()
{
  int n=5;
  int m=4;
  cout<<abs(5)<<end;
  cout<<swap<int>(m,n)<<endl;
}
```

- 函數模板的使用次序
  - 先找到參數匹配的普通函數
  - 再找到參數匹配的模板函數
  - 實參自動轉換匹配的普通函數
  - 以上都找不到，報錯
  
## 類模板

- [類模板和模板類](https://blog.csdn.net/sunxx1986/article/details/6619144)
  - 類模板是一個模板
  - 模板類是一個類模板的實體

```
template <class T>
class TestClass
{
  public:
  T buffer[10];
  T getData[int j];
};
template <class T>
T TestClass <T>::getData(int j)
{
  return *(buffer+j);
}
```
