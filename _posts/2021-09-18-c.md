---
title: '04737-C++程序設計'
date: 2021-09-28
permalink: /posts/2021/10/04737/
tags:
  - C++
category:
  - Computer Science
---


- [挺好的解釋網站](https://openhome.cc/Gossip/CppGossip/index.html)


# 第四章

## 解析函數
- 沒有參數,沒有返回植
- 有且只有一個
- 不會有重載的析構函數


## 靜態變量
- static: 靜態全局變量
- 在函體中可見,程序結束時釋放占用的空間,所以若在函數內定義, 出了函數就消失
- 類的靜態成員函數沒有this指針
- 靜態成員函數井不作用某個具體對象,不會改變對象中非靜態成員變量的值
- 不能在靜態成員函數內訪問非靜態的成員
- 靜態成員都只有一份保存在公用內存中
- 必須在類體外定義靜態成員變量的初值


## 常量成員和常引用成員
- 它既可以調用常量成員函數, 也可以調用普通成員函數
- 靜態成員函數井不作用某個具體對象,不會改變對象中非靜態成員變量的值,所以常數成員函數和非常量成員函數內部都可以調用靜態成員變量的值
- const成員變量必須在構造函數的初始化列表中進行初始化


# 第四章

- ```this```是指向类或者结构体本身的指针，并且不可以改变。
- ```*this```就是指向本身的类或结构体的变量。
- ```*p=&a``` *p是指標變量,可以存地址, &a 是a 的地址
- ```p```是地址, ```*p```是該地址的值
- ```int *p=new int()```在這段程式中，new 運算子會配置 int 需要的空間，並傳回該空間的位址，可以使用指標 p 來儲存位址


# 第五章
- 基類有友元類或友元函數,派生類不會因繼承關係而也有此友元類或友元函數。
- 基類是某類的友元, 是會被繼承
- 除基類的構造函數和析構函數外,派生類可以繼承基類的全部成員變量和成員函數

# 第六章
## 多態與虛函數
- P.245
- 多態為了接口复用
- 多態前不能提前知曉指針指向，函數調用與代碼入口地址需要綁定時才能確定，為**動態綁定**
- 早綁定是靜態綁定

滿足動態綁定的2個條件
- 必須聲明虛函數
- 通過基類類型指針或引用調用虛函數

虛函數：  
- 通常虛函數不是內聯函數
- 實現多態是派生和基類的同名函數，參數列表，返回值都一樣
- 基類定義了虛，派生也是虛
- 靜態成員函數和友元函數不能為虛
- 虛函數定義在類外，只而聲明時加 virtal ,定義時不用
- 構造函數不能是虛函數,operator=最好也不要是虛函數
- 構造和析構最好不要調用虛函數

不能聲明為虛函數： 
- 全局函數不能是虛
- 構造不能是虛
- 靜態
- 內聯成員函數
- 友元

  

## 虛析構函數
- p.263
- 沒有返回值
- 沒有參數
- 對象消忘時實現多態
  
```
int main()
{
  ABase *p=new Derived();
  delete p; return 0;
}
```
- 若基類的析構函數是虛，```delete p```就是先執行Derived析構函數 , 後執行base析構函數
- 若基類的析構函數不是虛，```delete p```就是執行base析構函數

## 純虛函數
- p.266
- 不可創純虛函數的對象，但可引用或指針。

## 虛基類

- A是基
- B，C是A的派生
- D，是B和C的派生

```C
class B :virtual public A
{};
Class C : virtual public A
{};
Class D:public B,public C
{};
```


# 第七章
- P.277
- iomanip包括了格式化I/O帶參數操縱符
- cerr非緩沖輸出流
- clog緩沖輸出流

```C
if (cin.eof()){}
```

##  控制I/O操縱符
- iostream
  - endl:新行符，清空流(O)
  - ends:(O)
  - flush：清空緩沖區(O)
  - dec*:10進制(I/O)
  - hex：16進制(I/O)
  - oct:8進制(I/O)
  - ws：提取空白符(O)
  
- iomainip
  - p.284
  - fixed:小數記數
  - left:向左靠
  - right*:向右靠
  - scientific：科學記數
  - setbase()：數字的基
  - setw()：輸出的寬
  - setfill():空的位置的填滿符
  - setprecision：小數或科學的小數後準確度，若不是fixed或scientific，就是從頭的數字數起，而不是小數後數起

```C
double x=1.23456789
cout<<setprecision(x); // 1.2346
cout<<fixed<<setprecision(x); // 1.23457
cout<<scientific<<setprecision(x); // 1.23457e+000
```


